#' prints an mtlr object
#'
#' @param x an mtlr object
#' @param digits The number of digits to print mtlr weights
#' @param ... for future methods.
#' @export
print.mtlr <- function(x, digits = max(3, getOption("digits")), ...){
  cat("\nCall: ", deparse(x$Call), "\n")
  cat("\nTime points:\n")
  print(x$time_points, digits = digits)
  cat("\n\nWeights:\n" )
  print(x$weight_matrix,digits = digits)
}


#' Predict method for MTLR class.
#'
#' @param object an object with class mtlr, generated by mtlr().
#' @param newdata a dataframe consisting of the same variables mtlr was trained on.
#' @param type the type of prediciton. Currently only response is supported (response gives survival curves).
#' @param add_zero a boolean specifying
#' @param ... for future methods.
#' @export
predict.mtlr <- function(object, newdata, type = c("survivalcurve","prob_event","mean_time","median_time"), add_zero = T,...){
  type = match.arg(type)
  if(missing(newdata)){
    newframe = object$x
  }else{
    Terms <- object$Terms
    Terms <- stats::delete.response(Terms)
    newframe <- stats::model.matrix(Terms, data=newdata,
                             xlev=object$xlevels)
    newframe <- newframe[,-1] #Remove intercept term.
    if(!is.null(object$scale)){
      newframe <- scale(newframe, center = object$scale$center, scale = object$scale$sd)
    }
  }

  surv_probs <- mtlr_predict(c(object$weight_matrix), newframe)
  #Issue due to machine precision, we get survival probabilities of 1+e-16. So here we adjust for that.
  surv_probs[surv_probs > 1] <- 1
  if(add_zero){
      time_points <- c(0,object$time_points)
      surv_probs <- rbind(1,surv_probs)
  }else{
    time_points <- object$time_points
  }
  surv_curves <- cbind.data.frame(time = time_points,surv_probs)
  switch(type,
         survivalcurve = surv_curves,
         prob_event = {
           mf <- stats::model.frame(object$Terms, newdata)
           y <- stats::model.response(mf)
           event_times <- y[,1]
           sapply(1:(ncol(surv_curves)-1), function(i) predict_prob(surv_curves[,i+1], time_points,event_times[i]))
         },
         mean_time = {
           sapply(1:(ncol(surv_curves)-1),function(i) predict_mean(surv_curves[,i+1], time_points))
         },
         median_time = {
           sapply(1:(ncol(surv_curves)-1),function(i) predict_median(surv_curves[,i+1], time_points))
         }
  )
}

#' Plot the weights of the mtlr object across time. The numfeatures = 5 default plots the the 5 most influential features
#' as determined by the sum of absolute values of feature weights across time. The bias is ignored in these calculations.
#'
#'@param x an object of class mtlr, returned by the mtlr function.
#'@param numfeatures the number of weight to plot. Default is 5.
#'@param weightnames the names of the specific weight to plot. These should correspond to the names
#'in mtlr$weight_matrix. If weightnames are supplied, then numfeatures is ignored.
#'@param digits the number of digits to round to for the time points.
#'@param ... for future methods
#'@export
plot.mtlr <- function(x, numfeatures=5, weightnames = c(), digits, ...) {
  if (requireNamespace(c("ggplot2","reshape2"), quietly = TRUE)) {
    weights <- x$weight_matrix
    time_points <- x$time_points
    if(!length(weightnames)){
      influence <- get_param_influence(x)
      if(numfeatures > length(influence)){
        warning("Number of features specified greater than the total number of features. This has been replaced with the total number of features.")
        numfeatures = length(influence)
      }
      top_weights <- influence[order(influence, decreasing = T)[1:numfeatures]]
      top_weight_names <- names(top_weights)
      weight_index <- match(top_weight_names, colnames(weights))
    }else{
      weight_index = match(weightnames, colnames(weights))
    }
    plot_weights <- weights[,weight_index, drop = FALSE]
    chr_time <- as.character(round(time_points,digits))
    plot_data <- cbind.data.frame(time = chr_time, plot_weights)
    plot_data = reshape2::melt(plot_data,id.vars = "time")
    ggplot2::ggplot(plot_data, ggplot2::aes(x = plot_data$time,
                                            y = plot_data$value,
                                            group = plot_data$variable,
                                            color = plot_data$variable)) +
      ggplot2::geom_point(size = 2.5) +
      ggplot2::geom_line(size = 1.25) +
      ggplot2::scale_x_discrete("Event Time", limits = chr_time)+
      ggplot2::theme_bw() +
      ggplot2::labs(y = "Weight", color = "Feature") +
      ggplot2::theme(text = ggplot2::element_text(size = 16),
            axis.text = ggplot2::element_text(size = 12, face = "bold"))
  } else {
    warning("Installing ggplot2 and reshape2 will given a more informative plot.")
    influence <- get_param_influence(x)
    graphics::barplot(influence, ylab = "Influence", xlab = "Feature")
  }
}




















